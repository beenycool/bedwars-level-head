<<<<<<< SEARCH
    // Add SWR stale headers if data is stale
    if (resolved.isStale) {
      res.set('X-Cache-Stale', '1');
      const ageSeconds = Math.floor((resolved.staleAgeMs ?? 0) / 1000);
      res.set('Age', ageSeconds.toString());
    }

    res.statusCode = 200;
=======
    // Add SWR stale headers if data is stale
    if (resolved.isStale) {
      res.set('X-Cache-Stale', '1');
      const ageSeconds = Math.floor((resolved.staleAgeMs ?? 0) / 1000);
      res.set('Age', ageSeconds.toString());
    }

    res.set('X-Cache', resolved.source === 'cache' ? 'HIT' : 'MISS');

    res.statusCode = 200;
>>>>>>> REPLACE
<<<<<<< SEARCH
          return {
            identifier,
            payload: {
              ...resolved.payload,
              ...(resolved.isStale ? { stale: true } : {}),
            },
          };
=======
          return {
            identifier,
            payload: {
              ...resolved.payload,
              ...(resolved.isStale ? { stale: true } : {}),
            },
            source: resolved.source,
          };
>>>>>>> REPLACE
<<<<<<< SEARCH
    const payloadMap: Record<string, ResolvedPlayer['payload']> = {};
    results.forEach((result) => {
      if (result) {
        payloadMap[result.identifier] = result.payload;
      }
    });

    const circuitBreaker = getCircuitBreakerState();
=======
    const payloadMap: Record<string, ResolvedPlayer['payload']> = {};
    let cacheHits = 0;
    let total = 0;
    results.forEach((result) => {
      if (result) {
        payloadMap[result.identifier] = result.payload;
        total++;
        if ((result as any).source === 'cache') {
          cacheHits++;
        }
      }
    });

    if (total > 0) {
      res.set('X-Cache', cacheHits === total ? 'HIT' : cacheHits > 0 ? 'PARTIAL' : 'MISS');
    }

    const circuitBreaker = getCircuitBreakerState();
>>>>>>> REPLACE
