diff --git a/build.gradle.kts b/build.gradle.kts
index f617fdb..227f1f8 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -38,6 +38,8 @@ repositories {
     maven("https://repo.polyfrost.org/releases")
     maven("https://repo.polyfrost.cc/releases")
     maven("https://repo.spongepowered.org/repository/maven-public/")
+    // Essential repository for gg.essential artifacts (UGraphics, UMatrixStack, etc.)
+    maven("https://repo.essential.gg/repository/maven-public")
 }
 
 val embed by configurations.creating
@@ -52,6 +54,8 @@ configurations.configureEach {
 dependencies {
     val oneconfig = "cc.polyfrost:oneconfig-$platform:0.2.2-alpha+"
     val universalcraft = "cc.polyfrost:universalcraft-$platform:246"
+    val essentialForge = "gg.essential:essential-1.8.9-forge:1.3.10.2"
+    val essentialLoader = "gg.essential:loader-launchwrapper:1.1.3"
 
     modCompileOnly(oneconfig)
     modImplementation(oneconfig)
@@ -61,6 +65,10 @@ dependencies {
     modCompileOnly(universalcraft)
     modImplementation(universalcraft)
 
+    // Essential is used for rendering (UGraphics/UMatrixStack) and is embedded via the loader
+    compileOnly(essentialForge)
+    embed(essentialLoader)
+
     embed(kotlin("stdlib"))
     embed("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")
     embed("com.squareup.okhttp3:okhttp:3.14.9")
diff --git a/src/main/kotlin/club/sk1er/mods/levelhead/render/AboveHeadRender.kt b/src/main/kotlin/club/sk1er/mods/levelhead/render/AboveHeadRender.kt
index 263f297..59d3a8e 100644
--- a/src/main/kotlin/club/sk1er/mods/levelhead/render/AboveHeadRender.kt
+++ b/src/main/kotlin/club/sk1er/mods/levelhead/render/AboveHeadRender.kt
@@ -4,18 +4,28 @@ import club.sk1er.mods.levelhead.Levelhead
 import club.sk1er.mods.levelhead.Levelhead.displayManager
 import club.sk1er.mods.levelhead.config.LevelheadConfig
 import club.sk1er.mods.levelhead.core.BedwarsModeDetector
+import club.sk1er.mods.levelhead.display.LevelheadTag
+import gg.essential.universal.UGraphics
+import gg.essential.universal.UMatrixStack
 import net.minecraft.client.Minecraft
 import net.minecraft.client.renderer.GlStateManager
 import net.minecraft.entity.player.EntityPlayer
 import net.minecraftforge.client.event.RenderLivingEvent
 import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
+import org.lwjgl.opengl.GL11
+import java.awt.Color
 import java.util.UUID
 import java.util.concurrent.ConcurrentHashMap
 
+/**
+ * Essential-based nametag renderer using UGraphics for optimized rendering.
+ * This implementation mirrors Sk1er's original Levelhead renderer, leveraging
+ * Essential's batching and GL state management for better performance.
+ */
 object AboveHeadRender {
     // Track last render time per player for throttling
     private val lastRenderTime: ConcurrentHashMap<UUID, Long> = ConcurrentHashMap()
-    
+
     // Clean up old render time entries periodically to prevent memory leaks
     private var lastCleanupTime: Long = 0
     private const val CLEANUP_INTERVAL_MS = 60000L // Clean up every minute
@@ -25,7 +35,7 @@ object AboveHeadRender {
         val now = System.currentTimeMillis()
         if (now - lastCleanupTime < CLEANUP_INTERVAL_MS) return
         lastCleanupTime = now
-        
+
         val cutoff = now - MAX_ENTRY_AGE_MS
         lastRenderTime.entries.removeIf { it.value < cutoff }
     }
@@ -52,7 +62,7 @@ object AboveHeadRender {
         // Render distance culling - early return before expensive operations
         val renderDistance = displayManager.config.renderDistance
         val distanceSq = entity.getDistanceSqToEntity(localPlayer)
-        val maxDistanceSq = (renderDistance * renderDistance).coerceAtMost(4096.0)
+        val maxDistanceSq = (renderDistance * renderDistance).toDouble().coerceAtMost(4096.0)
         if (distanceSq > maxDistanceSq) return
 
         // Render throttling check
@@ -79,113 +89,113 @@ object AboveHeadRender {
         // Retrieve the cached stats tag for this player
         val tag = display.cache[entity.uniqueID] ?: return
 
-        // Build the text to display
-        val text = "${tag.header.value}${tag.footer.value}"
-        if (text.isBlank()) return
+        // Render the tag using Essential's UGraphics
+        render(tag, event.x, event.y + entity.height + 0.5, event.z, entity.isSneaking)
+    }
 
-        // Calculate position
-        val x = event.x
-        var y = event.y + entity.height + 0.5
-        val z = event.z
+    /**
+     * Renders a Levelhead tag above a player's head using Essential's UGraphics.
+     * This method handles all GL state management, matrix transformations, and text rendering.
+     */
+    private fun render(tag: LevelheadTag, x: Double, y: Double, z: Double, sneaking: Boolean) {
+        val matrixStack = UMatrixStack()
+        val minecraft = Minecraft.getMinecraft()
+        val fontRenderer = minecraft.fontRendererObj
+        val renderManager = minecraft.renderManager
 
-        // Adjust for sneaking
-        if (entity.isSneaking) {
-            y -= 0.25
-        }
+        // Get the full string to display
+        val text = tag.getString()
+        if (text.isBlank()) return
 
-        // Begin OpenGL rendering
-        GlStateManager.pushMatrix()
+        // Calculate string width (uses cached width from LevelheadComponent when available)
+        val headerWidth = tag.header.getWidth(fontRenderer)
+        val footerWidth = tag.footer.getWidth(fontRenderer)
+        val stringWidth = headerWidth + footerWidth
+        val halfWidth = stringWidth shr 1
 
-        // Translate to position above player's head
-        GlStateManager.translate(x, y, z)
+        // Adjust Y position for sneaking
+        val adjustedY = if (sneaking) y - 0.25 else y
 
-        // Setup normal vector
-        GlStateManager.glNormal3f(0.0f, 1.0f, 0.0f)
+        // Push matrix and begin transformations
+        matrixStack.push()
+        matrixStack.translate(x, adjustedY, z)
 
         // Rotate to face the player (billboard effect)
-        val renderManager = minecraft.renderManager
-        GlStateManager.rotate(-renderManager.playerViewY, 0.0f, 1.0f, 0.0f)
-        GlStateManager.rotate(renderManager.playerViewX, 1.0f, 0.0f, 0.0f)
+        GL11.glNormal3f(0.0f, 1.0f, 0.0f)
+        matrixStack.rotate(-renderManager.playerViewY, 0.0f, 1.0f, 0.0f)
+        matrixStack.rotate(renderManager.playerViewX, 1.0f, 0.0f, 0.0f)
 
-        // Apply scaling with config value, guard against zero or negative values
+        // Apply scaling with config value
         val MIN_SCALE_EPSILON = 0.001f
         val effectiveScale = kotlin.math.max(kotlin.math.abs(LevelheadConfig.textScale), MIN_SCALE_EPSILON)
-        val scale = 0.025f * effectiveScale
-        GlStateManager.scale(-scale, -scale, scale)
+        val scale = -0.025f * effectiveScale
+        matrixStack.scale(scale, scale, scale)
 
-        // Setup OpenGL state for text rendering
+        // Setup GL state for rendering
         GlStateManager.disableLighting()
         GlStateManager.depthMask(false)
         GlStateManager.enableBlend()
-        GlStateManager.tryBlendFuncSeparate(770, 771, 1, 0)
-        GlStateManager.disableTexture2D()
+        GlStateManager.tryBlendFuncSeparate(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA, GL11.GL_ONE, GL11.GL_ZERO)
 
-        val fontRenderer = minecraft.fontRendererObj
-        
-        // Calculate widths for proper centering
-        val headerText = tag.header.value
-        val footerText = tag.footer.value
-        val headerWidth = fontRenderer.getStringWidth(headerText)
-        val footerWidth = fontRenderer.getStringWidth(footerText)
-        val totalWidth = headerWidth + footerWidth
-        val halfWidth = totalWidth / 2
+        // Draw background if enabled
+        if (displayManager.config.showBackground) {
+            GlStateManager.disableTexture2D()
+
+            val opacity = displayManager.config.backgroundOpacity
+            val alpha = (opacity * 255).toInt().coerceIn(0, 255)
+            val backgroundColor = Color(0, 0, 0, alpha)
+
+            // Use UGraphics for optimized background rendering
+            val worldRenderer = UGraphics.getFromTessellator()
+            @Suppress("DEPRECATION")
+            worldRenderer.beginWithDefaultShader(UGraphics.DrawMode.QUADS, UGraphics.CommonVertexFormats.POSITION_COLOR)
+
+            val left = -halfWidth - 2
+            val right = halfWidth + 2
+            val top = -2
+            val bottom = fontRenderer.FONT_HEIGHT
 
-        // Draw semi-transparent background
-        val backgroundColor = 0x40000000 // 25% opacity black
-        drawRect(-halfWidth - 2, -2, halfWidth + 2, fontRenderer.FONT_HEIGHT, backgroundColor)
+            worldRenderer.pos(matrixStack, left.toDouble(), bottom.toDouble(), 0.0).color(backgroundColor).endVertex()
+            worldRenderer.pos(matrixStack, right.toDouble(), bottom.toDouble(), 0.0).color(backgroundColor).endVertex()
+            worldRenderer.pos(matrixStack, right.toDouble(), top.toDouble(), 0.0).color(backgroundColor).endVertex()
+            worldRenderer.pos(matrixStack, left.toDouble(), top.toDouble(), 0.0).color(backgroundColor).endVertex()
 
-        // Re-enable textures for text rendering
-        GlStateManager.enableTexture2D()
+            worldRenderer.drawDirect()
 
-        // Determine colors to use - preserve per-section colors
+            GlStateManager.enableTexture2D()
+        }
+
+        // Determine colors to use
         val headerColor = if (LevelheadConfig.useCustomColor) {
             LevelheadConfig.starColor.rgb
         } else {
             tag.header.color.rgb
         }
-        
+
         val footerColor = if (LevelheadConfig.useCustomColor) {
             LevelheadConfig.starColor.rgb
         } else {
             tag.footer.color.rgb
         }
 
-        // Draw header and footer separately with their respective colors
-        val startX = -halfWidth.toFloat()
+        // Draw header and footer text with their respective colors
+        val startX = -halfWidth
+        val headerText = tag.header.value
+        val footerText = tag.footer.value
+
         if (headerText.isNotBlank()) {
-            fontRenderer.drawStringWithShadow(headerText, startX, 0f, headerColor)
+            fontRenderer.drawStringWithShadow(headerText, startX.toFloat(), 0f, headerColor)
         }
         if (footerText.isNotBlank()) {
-            fontRenderer.drawStringWithShadow(footerText, startX + headerWidth, 0f, footerColor)
+            fontRenderer.drawStringWithShadow(footerText, (startX + headerWidth).toFloat(), 0f, footerColor)
         }
 
-        // Cleanup OpenGL state
+        // Restore GL state
         GlStateManager.depthMask(true)
         GlStateManager.enableLighting()
         GlStateManager.disableBlend()
         GlStateManager.color(1.0f, 1.0f, 1.0f, 1.0f)
-        GlStateManager.popMatrix()
-    }
 
-    /**
-     * Draws a rectangle using OpenGL.
-     * This is used for the semi-transparent background behind the text.
-     */
-    private fun drawRect(left: Int, top: Int, right: Int, bottom: Int, color: Int) {
-        val alpha = (color shr 24 and 255) / 255.0f
-        val red = (color shr 16 and 255) / 255.0f
-        val green = (color shr 8 and 255) / 255.0f
-        val blue = (color and 255) / 255.0f
-
-        val tessellator = net.minecraft.client.renderer.Tessellator.getInstance()
-        val worldRenderer = tessellator.worldRenderer
-
-        GlStateManager.color(red, green, blue, alpha)
-        worldRenderer.begin(7, net.minecraft.client.renderer.vertex.DefaultVertexFormats.POSITION)
-        worldRenderer.pos(left.toDouble(), bottom.toDouble(), 0.0).endVertex()
-        worldRenderer.pos(right.toDouble(), bottom.toDouble(), 0.0).endVertex()
-        worldRenderer.pos(right.toDouble(), top.toDouble(), 0.0).endVertex()
-        worldRenderer.pos(left.toDouble(), top.toDouble(), 0.0).endVertex()
-        tessellator.draw()
+        matrixStack.pop()
     }
 }
